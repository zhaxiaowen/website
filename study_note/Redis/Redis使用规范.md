# Redis使用规范

### Redis Cluster模式介绍

#### Redis集群的概念

* 支持分区水平扩展,自动将数据分散存储到不同Redis实例中
* 提供新接电脑识别能力、故障判断及故障转移能力
* 一个集群最少3个节点,最大1000个节点

#### Redis Cluster特点

* 无中心化架构,所有的节点相互连接
* 节点与节点之间通过二进制协议进行通信
* 客户端和集群节点之间通信和通常一样,通过文本协议进行
* 集群节点不会代理查询
* 一致性保证:最终一致性
* 节点粒度备份,不像C*等分布式系统采用了分区级别备份

#### Redis集群实现问题

* 键的批量操作支持有限,比如mset,mget,如果多个键映射在不同的槽,就不支持了
* 键事务支持有限,当多个key分布在不同节点时无法使用事务,同一节点是支持事务
* 键是数据分区的最小粒度,不能将一个很大的键值对映射到不同的节点
* 不支持多数据库,只有0,select 0

#### Redis Cluster模式介绍--键空间、HASH标签、MOVED/ASK转向

* 键空间分布模式
  1. Redis集群的键空间被分割为16384个槽
  2. 理论上集群的最大节点数量也是16384个,推荐的最大节点数量为500个左右
  3. 每个主节点都负责处理16384个哈希槽的其中一部分

* 键哈希标签(Hash Tag)
  1. 键哈希标签是一种可以让用户指定将一批键都能够被存放在同一个槽中的实现方法
  2. 如果在key中使用{},redis将基于{}中的数据计算slot
* MOVE/ASK重定向
  1. 如果集群的路由信息发生变化,列入扩容缩容之后,客户端向节点访问一个其他节点的key,这时候节点就会向客户端返回MOVED信息,这个信息是按照redis错误信息格式发送包含正确目的地节点地址,客户端收到MOVED报错就会解析报错信息,再次请求
  2. ASK重定向的原理与MOVED相同,只是使用场景不同,ASKED用于节点slot迁移时,客户端恰好访问到正在迁移的slot上的key时,节点会返回ASKED

#### Redis Cluster集群模式--重新分片

* 重新分片
  1. 重新分片后,槽到集群节点的映射关系会改变,键到槽的映射关系不变
  2. 槽迁移的过程中有一个不稳定状态会有一些规则需要客户端配合
* 槽迁移流程
  1. 假设节点A迁移Slot到节点B,节点A设置为MIGRATING状态,节点B设置为IMPORTING状态
  2. 调用migrate指令迁移所有该slot的数据到节点B
  3. 消除节点A和节点B IMPORTING和MIGRATING状态,并且设置槽位映射到节点B
* MIGRATING状态
  1. 如果Key存在则成功处理
  2. 如果key不存在,则返回客户端ASK,仅当这次请求会转向另一个节点
* IMPORTING状态
  1. 争创命令会被MOVED重定向,如果是ASKING命令则命令会被执行,从而key没有在老的节点已经被迁移到新的节点的情况可以被顺利处理
  2. 如果key不存在则新建
  3. 没有ASKING的请求和正常请求一样被MOVED,这保证客户端node映射关系出错的情况不会发生写错

#### DCS组件介绍--整体架构

* 缓存引擎:redis4.0.11,并使用其集群特性
* 内部通信:使用ETCD作为分布式系统消息通信服务
* Manager:包含Web UI,作为分布式缓存服务及基础设施的管理系统
* Agent:对应物理节点的代理服务,辅助Manager进行Redis实例控制及监控
* SDK:应用调用分布式缓存服务的入口,使用redis4.0.11自身集群特性

#### DCS双云同步-切换

* 依赖消息队列,实现双云数据同步
* 由于插入DMQ和DCConsumer消费顺序的不确定性,DCS无法保证双云集群数据一致性
* 主备集群数据不一致
* 集群存在脏数据
* DCSDK通过订阅DCG获取主备集群权重
* 权重变化后DCSDK会及时响应进行切换

#### DCS使用规范

* 缓存数据不宜过大
  1. 大key:string类型数据量大于10k,集合类型的size超过5000
  2. 风险:单次读取/写入数据量越大,DCS的性能下降越明显
* 禁止强依赖DCS
* 避免出现热点数据
* 缓存设置过期时间
* 高位接口使用
  1. 避免使用O(N)操作命令:如hgetall,smember,lrange 0 -1,zrange 0 -1

| 类型 | CPU  | Memory(GB) | Disk  | 最小服务器数 | 单agent上redis进程数 | Redis maxmemory | 单份数据GB |      |      |
| ---- | ---- | ---------- | ----- | ------------ | -------------------- | --------------- | ---------- | ---- | ---- |
|      | 4    | 4          | 100GB | 3            | 2                    | 1.2             | 0-8.2      |      |      |
|      | 8    | 8          | 100GB | 3            | 2                    | 2.4             | 72.-14.4   |      |      |
|      | 16   | 16         | 100GB | 3            | 2                    | 4.8             | 14.4-28.8  |      |      |
|      | 32   | 32         | 100GB | 3            | 4                    | 4.8             | 28.8-57.6  |      |      |
|      | 64   | 64         | 100GB | 3            | 6                    | 6.4             | 57.6-115.2 |      |      |
|      | 128  | 128        | 100GB | 3            | 12                   | 6.4             | >115.2     |      |      |
|      |      |            |       |              |                      |                 |            |      |      |

### Redis性能优化

#### 1.网络

* 使用multi-key指令合并多个指令,减少请求次数
* 使用transaction、script合并requests以及response,但是要求涉及的key在同一个Node上
* 使用pipeline合并response

#### 2.警惕执行时间过长的操作

* keys * ; LRANGE ;hgetall;zrabge;sinter;不使用复杂O(N)及以上的指令
* transaction、script合并多个command是一个具有原子性的执行过程,也可能占用redis较长时间
* 不使用DEL、SAVE等会阻塞主线程的指令,使用UNLINKL、bgsave
* 保证key不会集中过期
* 频繁的新增会导致内存碎片增多,定期清理内存碎片

#### 3.使用建议

* **string类型控制在10KB以内**，hash、list、set、zset**元素尽量不超过5000**
* redis事务功能较弱,尽量少用
* 短连接性能差,推荐使用带有连接池的客户端
